# Tutorial 01: Basic GitLab CI Pipeline

## Objectives

By the end of this tutorial, you will:
- Understand the basic structure of a `.gitlab-ci.yml` file
- Learn about GitLab CI jobs, stages, and pipelines
- Create your first CI pipeline with multiple stages
- Understand GitLab CI runners and execution environments
- Learn to view pipeline runs and logs in GitLab UI

## Prerequisites

- GitLab account (GitLab.com or self-hosted)
- Git installed locally
- Basic understanding of YAML syntax
- A GitLab repository (public or private)
- Text editor or IDE

## What is GitLab CI/CD?

GitLab CI/CD is a built-in continuous integration and deployment tool in GitLab. Pipelines are defined in a `.gitlab-ci.yml` file at the root of your repository.

## Key Concepts

### Pipeline
A pipeline is a group of jobs that are executed in stages. Pipelines are defined by a `.gitlab-ci.yml` file.

### Stage
A stage is a logical grouping of jobs. Jobs in the same stage run in parallel, and stages run sequentially.

### Job
A job defines what scripts to execute. Jobs are picked up by runners and executed within the environment of the runner.

### Runner
A runner is an agent that executes your CI/CD jobs. GitLab provides shared runners, or you can register your own.

### Artifact
Files generated by a job that can be downloaded or passed to subsequent jobs.

## Default Stages

If not specified, GitLab uses these default stages in order:
1. `.pre`
2. `build`
3. `test`
4. `deploy`
5. `.post`

## Step-by-Step Instructions

### Step 1: Create the Basic Pipeline Configuration

Create a file at the root of your repository: `.gitlab-ci.yml`

```yaml
# Define custom stages (optional - these are custom)
stages:
  - build
  - test
  - deploy

# Global variables available to all jobs
variables:
  APP_NAME: "my-application"
  APP_VERSION: "1.0.0"

# Global before_script runs before each job's script
before_script:
  - echo "Starting job execution..."
  - echo "Pipeline ID: $CI_PIPELINE_ID"
  - echo "Job ID: $CI_JOB_ID"

# Build job
build-job:
  stage: build
  script:
    - echo "Building the application..."
    - echo "App Name: $APP_NAME"
    - echo "App Version: $APP_VERSION"
    - mkdir -p build
    - echo "Build $(date)" > build/build-info.txt
    - echo "Commit: $CI_COMMIT_SHORT_SHA" >> build/build-info.txt
    - cat build/build-info.txt
  artifacts:
    paths:
      - build/
    expire_in: 1 hour

# Test job
test-job:
  stage: test
  script:
    - echo "Running tests..."
    - echo "Testing application $APP_NAME version $APP_VERSION"
    - ls -la build/
    - cat build/build-info.txt
    - echo "All tests passed!"
  dependencies:
    - build-job

# Deploy job
deploy-job:
  stage: deploy
  script:
    - echo "Deploying application..."
    - echo "Deploying to production server"
    - echo "Application deployed successfully!"
  environment:
    name: production
    url: https://example.com
  when: manual  # Requires manual trigger
```

### Step 2: Understanding the Pipeline Structure

Let's break down each section:

```yaml
stages:
  - build
  - test
  - deploy
```
Defines the stages and their execution order. Stages run sequentially.

```yaml
variables:
  APP_NAME: "my-application"
```
Global variables accessible in all jobs via `$APP_NAME`.

```yaml
build-job:
  stage: build
  script:
    - echo "Building..."
```
A job named `build-job` that runs in the `build` stage.

```yaml
artifacts:
  paths:
    - build/
  expire_in: 1 hour
```
Stores the `build/` directory and makes it available to other jobs. Expires after 1 hour.

```yaml
dependencies:
  - build-job
```
Downloads artifacts from the specified job(s).

```yaml
when: manual
```
Job requires manual trigger from the GitLab UI.

### Step 3: Create a Multi-Stage Pipeline Example

Create `.gitlab-ci.yml` with more detailed stages:

```yaml
stages:
  - validate
  - build
  - test
  - deploy

# Validation stage - runs first
validate-code:
  stage: validate
  script:
    - echo "Validating code structure..."
    - echo "Checking file permissions..."
    - ls -la
    - echo "Validation complete!"

# Build stage - runs after validate
build-application:
  stage: build
  script:
    - echo "Compiling source code..."
    - mkdir -p dist
    - echo "Application built at $(date)" > dist/app.txt
    - echo "Build successful!"
  artifacts:
    paths:
      - dist/
    expire_in: 1 day

# Test stage - runs after build (parallel jobs)
unit-test:
  stage: test
  script:
    - echo "Running unit tests..."
    - ls -la dist/
    - echo "Unit tests passed!"
  dependencies:
    - build-application

integration-test:
  stage: test
  script:
    - echo "Running integration tests..."
    - echo "Integration tests passed!"
  dependencies:
    - build-application

# Deploy stage - runs after all tests pass
deploy-staging:
  stage: deploy
  script:
    - echo "Deploying to staging environment..."
    - echo "Staging deployment complete!"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy-production:
  stage: deploy
  script:
    - echo "Deploying to production environment..."
    - echo "Production deployment complete!"
  environment:
    name: production
    url: https://production.example.com
  only:
    - main
  when: manual
```

### Step 4: Create a Simple Application

Create a sample Python application to demonstrate the pipeline:

**File: `app/main.py`**

```python
#!/usr/bin/env python3
"""Simple application for GitLab CI demonstration."""

def greet(name):
    """Return a greeting message."""
    return f"Hello, {name}!"

def calculate(a, b):
    """Perform a simple calculation."""
    return a + b

def main():
    print(greet("GitLab CI"))
    print(f"Calculation result: {calculate(5, 3)}")
    print("Application is running successfully!")

if __name__ == "__main__":
    main()
```

**File: `app/test_main.py`**

```python
#!/usr/bin/env python3
"""Unit tests for the application."""

from main import greet, calculate

def test_greet():
    """Test the greet function."""
    assert greet("World") == "Hello, World!"
    assert greet("GitLab") == "Hello, GitLab!"
    print("✓ Greet tests passed")

def test_calculate():
    """Test the calculate function."""
    assert calculate(2, 3) == 5
    assert calculate(10, -5) == 5
    print("✓ Calculate tests passed")

if __name__ == "__main__":
    test_greet()
    test_calculate()
    print("All tests passed!")
```

### Step 5: Pipeline with Application Build and Test

Create `.gitlab-ci.yml` that builds and tests the application:

```yaml
stages:
  - build
  - test
  - package

variables:
  PYTHON_VERSION: "3.9"

build-app:
  stage: build
  image: python:3.9
  script:
    - echo "Setting up Python environment..."
    - python --version
    - pip --version
    - echo "Installing dependencies..."
    - pip install pytest
    - echo "Build complete!"
  artifacts:
    paths:
      - app/
    expire_in: 1 hour

test-app:
  stage: test
  image: python:3.9
  script:
    - echo "Running application tests..."
    - cd app
    - python test_main.py
    - echo "Tests passed successfully!"
  dependencies:
    - build-app

package-app:
  stage: package
  image: python:3.9
  script:
    - echo "Packaging application..."
    - mkdir -p package
    - cp app/*.py package/
    - tar -czf app-package.tar.gz package/
    - ls -lh app-package.tar.gz
    - echo "Package created successfully!"
  artifacts:
    paths:
      - app-package.tar.gz
    expire_in: 1 week
  dependencies:
    - build-app
```

## GitLab CI Predefined Variables

GitLab provides many predefined environment variables:

```yaml
script:
  - echo "CI: $CI"                           # Always true
  - echo "Pipeline ID: $CI_PIPELINE_ID"      # Unique pipeline ID
  - echo "Job ID: $CI_JOB_ID"                # Unique job ID
  - echo "Job Name: $CI_JOB_NAME"            # Job name
  - echo "Job Stage: $CI_JOB_STAGE"          # Current stage
  - echo "Commit SHA: $CI_COMMIT_SHA"        # Full commit SHA
  - echo "Short SHA: $CI_COMMIT_SHORT_SHA"   # Short commit SHA
  - echo "Branch: $CI_COMMIT_REF_NAME"       # Branch or tag name
  - echo "Project Name: $CI_PROJECT_NAME"    # Project name
  - echo "Project URL: $CI_PROJECT_URL"      # Project URL
  - echo "Runner: $CI_RUNNER_DESCRIPTION"    # Runner description
```

## Common Pipeline Patterns

### Run on Specific Branches

```yaml
job-for-main:
  script:
    - echo "Running on main branch"
  only:
    - main

job-for-develop:
  script:
    - echo "Running on develop branch"
  only:
    - develop
```

### Run on All Branches Except Specific Ones

```yaml
job-except-main:
  script:
    - echo "Running on all branches except main"
  except:
    - main
```

### Run on Tags

```yaml
release-job:
  script:
    - echo "Creating release"
  only:
    - tags
```

### Run on Merge Requests

```yaml
mr-job:
  script:
    - echo "Running on merge request"
  only:
    - merge_requests
```

## Verification Steps

### Local Validation

1. **Validate YAML syntax:**
   ```bash
   # Using Python
   python -c "import yaml; yaml.safe_load(open('.gitlab-ci.yml'))"

   # Using yamllint
   pip install yamllint
   yamllint .gitlab-ci.yml
   ```

2. **Check with GitLab CI Lint:**
   ```bash
   # Using GitLab API (requires access token)
   curl --header "Content-Type: application/json" \
        --header "PRIVATE-TOKEN: your_access_token" \
        --data @.gitlab-ci.yml \
        "https://gitlab.com/api/v4/ci/lint"
   ```

### GitLab Web UI Validation

1. **Via GitLab CI/CD Editor:**
   - Go to your project in GitLab
   - Navigate to CI/CD > Editor
   - Paste your `.gitlab-ci.yml` content
   - Click "Validate" to check syntax

2. **Via CI Lint Tool:**
   - Go to your project in GitLab
   - Navigate to CI/CD > Pipelines
   - Click "CI Lint" in the top right
   - Paste your configuration
   - Click "Validate"

### Running the Pipeline

1. **Commit and push:**
   ```bash
   git add .gitlab-ci.yml app/
   git commit -m "Add GitLab CI pipeline configuration"
   git push origin main
   ```

2. **View pipeline:**
   - Go to CI/CD > Pipelines in GitLab
   - Click on the running pipeline
   - View stages and job logs
   - Check job status (success/failed/running)

3. **Manual job trigger:**
   - For jobs with `when: manual`
   - Click the play button in the pipeline view
   - Confirm execution

## Troubleshooting

### Issue: Pipeline not triggering

**Problem:** Pushed code but pipeline doesn't run.

**Solutions:**
1. Check `.gitlab-ci.yml` is at repository root
2. Verify YAML syntax is valid
3. Check if CI/CD is enabled in Settings > General > Visibility
4. Ensure you have available runners (check Settings > CI/CD > Runners)
5. Check if branch restrictions are preventing execution

### Issue: YAML syntax errors

**Problem:** Pipeline fails with "YAML syntax is invalid" error.

**Solutions:**
1. Use CI Lint tool to validate
2. Check indentation (2 spaces, not tabs)
3. Ensure proper quoting of strings with special characters
4. Validate array and map syntax
5. Check for duplicate keys

### Issue: No runners available

**Problem:** Job stuck with "This job is stuck because you don't have any active runners."

**Solutions:**
1. Use shared runners: Settings > CI/CD > Runners > Enable shared runners
2. Register a specific runner for your project
3. Check runner tags match job requirements
4. Verify runners are active and not paused

### Issue: Artifacts not found

**Problem:** Job fails to download artifacts from previous job.

**Solutions:**
1. Ensure artifact paths are correct in the source job
2. Check artifacts haven't expired
3. Use `dependencies:` to specify which job's artifacts to download
4. Verify artifact upload was successful in previous job

### Issue: Jobs running in wrong order

**Problem:** Jobs execute in unexpected sequence.

**Solutions:**
1. Review stage definitions and order
2. Jobs in same stage run in parallel
3. Use `needs:` for specific job dependencies
4. Check for conditional execution (`only`, `except`, `when`)

## Best Practices

### 1. Use Descriptive Job Names

```yaml
# Good
build-backend-api:
  script: ...

test-unit-backend:
  script: ...

# Bad
job1:
  script: ...

job2:
  script: ...
```

### 2. Minimize Artifact Sizes

```yaml
artifacts:
  paths:
    - dist/  # Only necessary files
  exclude:
    - "*.log"
    - "node_modules/"
  expire_in: 1 week  # Set expiration
```

### 3. Use before_script and after_script Wisely

```yaml
# Global setup for all jobs
before_script:
  - echo "Global setup"

# Job-specific setup
job:
  before_script:
    - echo "Job-specific setup"
  script:
    - echo "Main script"
  after_script:
    - echo "Cleanup (always runs)"
```

### 4. Set Timeouts

```yaml
job:
  timeout: 1h  # Prevent hung jobs
  script:
    - long-running-command
```

### 5. Use Image Versioning

```yaml
# Good - specific version
image: python:3.9.18

# Bad - latest (unpredictable)
image: python:latest
```

### 6. Organize with YAML Anchors

```yaml
.base-job: &base-job
  image: python:3.9
  before_script:
    - pip install -r requirements.txt

job1:
  <<: *base-job
  script:
    - pytest

job2:
  <<: *base-job
  script:
    - flake8
```

### 7. Use Retry for Flaky Tests

```yaml
test:
  script:
    - npm test
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
```

## Advanced Pipeline Features

### Job Dependencies with `needs`

```yaml
stages:
  - build
  - test

build:
  stage: build
  script: ...

# Runs immediately after build, doesn't wait for stage
test:
  stage: test
  needs: [build]
  script: ...
```

### Parallel Execution

```yaml
test:
  parallel: 3
  script:
    - echo "Running parallel job ${CI_NODE_INDEX} of ${CI_NODE_TOTAL}"
```

### Rules-based Conditions

```yaml
job:
  script: echo "Hello"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - when: never
```

### Environment-specific Jobs

```yaml
deploy:
  script: deploy.sh
  environment:
    name: production
    url: https://example.com
    on_stop: stop_deploy
    auto_stop_in: 1 day

stop_deploy:
  script: stop.sh
  environment:
    name: production
    action: stop
  when: manual
```

## Pipeline Visualization

GitLab provides several views:

1. **Pipeline Graph:** Visual representation of stages and jobs
2. **Job Logs:** Detailed output from each job
3. **Pipeline Status:** Overview of pipeline execution
4. **Merge Request Pipelines:** Pipelines triggered by MRs

## Example: Complete Basic Pipeline

```yaml
# .gitlab-ci.yml
image: alpine:latest

stages:
  - prepare
  - build
  - test
  - deploy

variables:
  PROJECT_NAME: "demo-app"
  BUILD_DIR: "build"

# Cache dependencies
cache:
  paths:
    - .cache/

prepare:
  stage: prepare
  script:
    - echo "Preparing environment..."
    - mkdir -p .cache
    - echo "Environment ready"

build:
  stage: build
  script:
    - echo "Building ${PROJECT_NAME}..."
    - mkdir -p ${BUILD_DIR}
    - echo "Build timestamp: $(date)" > ${BUILD_DIR}/info.txt
    - echo "Build complete"
  artifacts:
    paths:
      - ${BUILD_DIR}/
    expire_in: 1 day

test:
  stage: test
  script:
    - echo "Running tests..."
    - cat ${BUILD_DIR}/info.txt
    - echo "Tests passed"
  dependencies:
    - build

deploy:
  stage: deploy
  script:
    - echo "Deploying ${PROJECT_NAME}..."
    - echo "Deployment successful"
  environment:
    name: production
  only:
    - main
  when: manual
```

## Additional Resources

- [GitLab CI/CD Documentation](https://docs.gitlab.com/ee/ci/)
- [.gitlab-ci.yml Reference](https://docs.gitlab.com/ee/ci/yaml/)
- [GitLab CI/CD Examples](https://docs.gitlab.com/ee/ci/examples/)
- [GitLab CI/CD Variables](https://docs.gitlab.com/ee/ci/variables/)
- [GitLab Runner Documentation](https://docs.gitlab.com/runner/)

## Next Steps

After completing this tutorial:
1. Experiment with different stage configurations
2. Try adding more jobs and dependencies
3. Explore job artifacts and dependencies
4. Move on to Tutorial 02: Testing with GitLab CI

## Summary

You've learned:
- How to create a basic GitLab CI pipeline with `.gitlab-ci.yml`
- Understanding stages, jobs, and their execution order
- Working with artifacts and dependencies
- Using GitLab CI predefined variables
- Configuring environment-specific deployments
- Best practices for pipeline configuration
- How to view and debug pipeline runs

This foundation prepares you for more advanced GitLab CI/CD patterns in subsequent tutorials.
