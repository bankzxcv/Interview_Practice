# Tutorial 07: Artifacts and Caching

## Objectives

By the end of this tutorial, you will:
- Understand GitLab CI artifacts and caching
- Implement efficient artifact management
- Configure cache for dependencies
- Use cache across pipeline stages
- Implement cache fallback strategies
- Optimize pipeline execution with caching
- Manage artifact expiration and cleanup

## Prerequisites

- Completed Tutorial 06: Secrets and Variables
- Understanding of GitLab CI pipelines
- Familiarity with build processes
- GitLab project with CI/CD enabled

## What are Artifacts and Cache?

**Artifacts** are files generated by jobs that can be downloaded or passed to subsequent jobs. They persist after job completion.

**Cache** stores dependencies and other files that don't change often between pipeline runs, speeding up job execution.

## Key Concepts

### Artifacts
- Files produced by jobs (build outputs, test reports, etc.)
- Downloadable from GitLab UI
- Passed between jobs and stages
- Have expiration policies
- Contribute to project storage

### Cache
- Speeds up pipeline execution
- Stores dependencies (node_modules, pip packages)
- Shared across pipelines and branches
- Has different policies (pull, push, pull-push)
- Does not guarantee availability

### Key Differences

| Feature | Artifacts | Cache |
|---------|-----------|-------|
| Purpose | Job outputs | Dependencies |
| Reliability | Guaranteed | Best effort |
| Passing between jobs | Yes | No |
| Downloadable | Yes | No |
| Persistence | Until expiration | Until cleanup |

## Step-by-Step Instructions

### Step 1: Basic Artifacts

Create `.gitlab-ci.yml` with artifacts:

```yaml
stages:
  - build
  - test
  - deploy

# Build with artifacts
build-app:
  stage: build
  script:
    - echo "Building application..."
    - mkdir -p dist/
    - echo "Build output" > dist/app.js
    - echo "Build metadata" > dist/metadata.json
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

# Use artifacts from previous job
test-app:
  stage: test
  script:
    - echo "Testing application..."
    - ls -la dist/
    - cat dist/app.js
  dependencies:
    - build-app

# Deploy using artifacts
deploy-app:
  stage: deploy
  script:
    - echo "Deploying application..."
    - ls -la dist/
    - echo "Deploying files from dist/"
  dependencies:
    - build-app
  when: manual
```

### Step 2: Advanced Artifact Configuration

Create `.gitlab-ci.yml` with advanced artifacts:

```yaml
stages:
  - build
  - test

# Multiple artifact paths
build-complete:
  stage: build
  script:
    - mkdir -p build/ logs/ reports/
    - echo "app" > build/app.bin
    - echo "log" > logs/build.log
    - echo "report" > reports/coverage.xml
  artifacts:
    name: "build-${CI_COMMIT_SHORT_SHA}"
    paths:
      - build/
      - logs/
      - reports/
    exclude:
      - logs/*.tmp
      - "**/*.log"
    when: on_success
    expire_in: 30 days

# Conditional artifacts
test-with-reports:
  stage: test
  script:
    - pytest tests/ --junitxml=report.xml --html=report.html
  artifacts:
    when: always # Upload even on failure
    reports:
      junit: report.xml
    paths:
      - report.html
      - htmlcov/
    expire_in: 1 month

# Artifacts with reports
coverage-test:
  stage: test
  image: python:3.11
  script:
    - pip install pytest pytest-cov
    - pytest --cov=app --cov-report=xml --cov-report=html
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
    expire_in: 30 days
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
```

### Step 3: Basic Caching

Create `.gitlab-ci.yml` with cache:

```yaml
stages:
  - build
  - test

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# Global cache configuration
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .cache/pip
    - .venv/

# Build with cache
build:
  stage: build
  image: python:3.11
  script:
    - pip install virtualenv
    - virtualenv .venv
    - source .venv/bin/activate
    - pip install -r requirements.txt
    - echo "Dependencies cached"

# Use cached dependencies
test:
  stage: test
  image: python:3.11
  script:
    - source .venv/bin/activate
    - pytest tests/
```

### Step 4: Advanced Caching Strategies

Create `.gitlab-ci.yml` with advanced caching:

```yaml
stages:
  - build
  - test

variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  CYPRESS_CACHE_FOLDER: "$CI_PROJECT_DIR/.cache/Cypress"

# Per-branch cache
.cache-template: &cache-template
  cache:
    key: ${CI_COMMIT_REF_SLUG}-${CI_JOB_NAME}
    paths:
      - .npm/
      - node_modules/
      - .cache/Cypress/
    policy: pull-push

# Build with cache
build:
  <<: *cache-template
  stage: build
  image: node:18
  script:
    - npm ci --cache .npm --prefer-offline
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 day

# Test with cache (pull only)
test-unit:
  stage: test
  image: node:18
  cache:
    <<: *cache-template
    policy: pull # Only pull, don't update
  script:
    - npm run test:unit

# E2E test with cache
test-e2e:
  stage: test
  image: cypress/base:18
  cache:
    key: ${CI_COMMIT_REF_SLUG}-cypress
    paths:
      - .npm/
      - .cache/Cypress/
    policy: pull
  script:
    - npm ci --cache .npm --prefer-offline
    - npx cypress run
  artifacts:
    when: always
    paths:
      - cypress/screenshots/
      - cypress/videos/
    expire_in: 7 days
```

### Step 5: Cache Fallback Keys

Create `.gitlab-ci.yml` with cache fallback:

```yaml
stages:
  - build
  - test

# Cache with fallback
build:
  stage: build
  image: python:3.11
  cache:
    key: 
      files:
        - requirements.txt
        - Pipfile.lock
      prefix: ${CI_COMMIT_REF_SLUG}
    paths:
      - .venv/
      - .cache/pip/
    fallback_keys:
      - ${CI_COMMIT_REF_SLUG}-
      - main-
      - default
  before_script:
    - pip install virtualenv
    - virtualenv .venv
    - source .venv/bin/activate
  script:
    - pip install -r requirements.txt
    - python setup.py build

test:
  stage: test
  image: python:3.11
  cache:
    key:
      files:
        - requirements.txt
      prefix: ${CI_COMMIT_REF_SLUG}
    paths:
      - .venv/
    policy: pull
  before_script:
    - source .venv/bin/activate
  script:
    - pytest tests/
```

### Step 6: Language-Specific Caching

**Python Example:**

```yaml
image: python:3.11

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .cache/pip
    - .venv/

before_script:
  - python -V
  - pip install virtualenv
  - virtualenv .venv
  - source .venv/bin/activate

build:
  script:
    - pip install -r requirements.txt
    - python setup.py build

test:
  script:
    - pip install -r requirements-dev.txt
    - pytest
```

**Node.js Example:**

```yaml
image: node:18

variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .npm/
    - node_modules/

build:
  script:
    - npm ci --cache .npm --prefer-offline
    - npm run build
  artifacts:
    paths:
      - dist/

test:
  script:
    - npm ci --cache .npm --prefer-offline
    - npm test
```

**Go Example:**

```yaml
image: golang:1.21

variables:
  GOPATH: $CI_PROJECT_DIR/.go

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .go/pkg/mod/

before_script:
  - mkdir -p .go

build:
  script:
    - go build -o myapp

test:
  script:
    - go test ./...
```

### Step 7: Distributed Cache

Create `.gitlab-ci.yml` with distributed cache:

```yaml
stages:
  - prepare
  - build
  - test

# Prepare cache
prepare-cache:
  stage: prepare
  image: node:18
  cache:
    key: ${CI_COMMIT_REF_SLUG}-deps
    paths:
      - node_modules/
    policy: push
  script:
    - npm ci
  only:
    changes:
      - package-lock.json

# Use cache in parallel jobs
build:
  stage: build
  parallel: 3
  image: node:18
  cache:
    key: ${CI_COMMIT_REF_SLUG}-deps
    paths:
      - node_modules/
    policy: pull
  script:
    - npm run build:part${CI_NODE_INDEX}
  artifacts:
    paths:
      - dist/part${CI_NODE_INDEX}/

# Test with cache
test:
  stage: test
  image: node:18
  cache:
    key: ${CI_COMMIT_REF_SLUG}-deps
    paths:
      - node_modules/
    policy: pull
  script:
    - npm test
```

### Step 8: Artifact Reports

Create `.gitlab-ci.yml` with various reports:

```yaml
stages:
  - test
  - report

# JUnit report
unit-test:
  stage: test
  image: python:3.11
  script:
    - pip install pytest pytest-cov
    - pytest tests/ --junitxml=report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml

# Coverage report
coverage-test:
  stage: test
  image: python:3.11
  script:
    - pip install pytest pytest-cov
    - pytest --cov=app --cov-report=xml
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'

# Performance report
performance-test:
  stage: test
  script:
    - ./run-performance-tests.sh
  artifacts:
    reports:
      performance: performance.json

# Code quality report
code-quality:
  stage: test
  image: python:3.11
  script:
    - pip install pylint
    - pylint app/ --output-format=json > codequality.json || true
  artifacts:
    reports:
      codequality: codequality.json

# Generate summary
generate-report:
  stage: report
  script:
    - echo "Generating consolidated report..."
    - cat << EOF > summary.md
      # Test Summary
      - Unit Tests: Passed
      - Coverage: 85%
      - Code Quality: B+
      EOF
  artifacts:
    paths:
      - summary.md
    expire_in: 1 year
```

## Verification Steps

### Local Testing

1. **Test artifact generation:**
   ```bash
   mkdir -p dist/
   echo "test" > dist/output.txt
   ls -la dist/
   ```

2. **Simulate cache:**
   ```bash
   # First run - populate cache
   npm install
   
   # Second run - use cache
   npm ci --prefer-offline
   ```

### GitLab CI Verification

1. **View artifacts:**
   - Go to CI/CD > Pipelines
   - Click on pipeline
   - Click "Browse" button to view artifacts
   - Download artifacts

2. **Check cache:**
   - View job logs
   - Look for "Checking cache for..." messages
   - Verify "Successfully extracted cache"

3. **Monitor storage:**
   - Go to Settings > Usage Quotas
   - Check artifacts storage
   - Review cache usage

## Troubleshooting

### Issue: Artifacts not found

**Problem:** Job can't find artifacts from previous job.

**Solutions:**
1. Add `dependencies:` to specify source job
2. Check artifact paths are correct
3. Verify artifacts haven't expired
4. Ensure source job completed successfully

### Issue: Cache not working

**Problem:** Cache isn't being used.

**Solutions:**
1. Check cache key is consistent
2. Verify cache paths exist
3. Ensure GitLab Runner has cache configured
4. Check cache policy (pull/push/pull-push)

### Issue: Cache is too large

**Problem:** Cache uploads take too long.

**Solutions:**
1. Exclude unnecessary files
2. Use specific paths
3. Split into multiple cache keys
4. Use cache compression
5. Review what's being cached

### Issue: Out of storage

**Problem:** Project exceeds storage quota.

**Solutions:**
1. Reduce artifact expiration times
2. Clean up old artifacts
3. Use smaller artifact sizes
4. Exclude unnecessary files
5. Request quota increase

## Best Practices

### 1. Use Appropriate Expiration
```yaml
artifacts:
  expire_in: 1 week # Short for builds
  # expire_in: 1 year # Long for releases
```

### 2. Cache Only Dependencies
```yaml
cache:
  paths:
    - node_modules/ # ✓ Dependencies
    # NOT dist/ # ✗ Build outputs (use artifacts)
```

### 3. Use Specific Cache Keys
```yaml
cache:
  key:
    files:
      - package-lock.json # Update when deps change
    prefix: ${CI_COMMIT_REF_SLUG}
```

### 4. Set Cache Policy Appropriately
```yaml
build:
  cache:
    policy: pull-push # Update cache

test:
  cache:
    policy: pull # Only read cache
```

### 5. Exclude Unnecessary Files
```yaml
artifacts:
  paths:
    - dist/
  exclude:
    - "**/*.log"
    - "**/*.tmp"
    - .git/
```

### 6. Use Artifact Names
```yaml
artifacts:
  name: "build-${CI_COMMIT_SHORT_SHA}"
  paths:
    - dist/
```

### 7. Upload on Failure
```yaml
artifacts:
  when: always # Upload even if job fails
  paths:
    - test-results/
```

## Performance Tips

### 1. Optimize Cache Size
- Cache only what's necessary
- Use exclude patterns
- Compress large files
- Clean up before caching

### 2. Use Cache Fallbacks
```yaml
cache:
  key: ${CI_COMMIT_REF_SLUG}
  fallback_keys:
    - main
    - default
```

### 3. Parallel Cache Usage
```yaml
# Separate cache for parallel jobs
cache:
  key: ${CI_COMMIT_REF_SLUG}-${CI_JOB_NAME}
```

### 4. Minimize Artifact Transfers
```yaml
# Only download needed artifacts
dependencies:
  - build # Only build artifacts
```

## Additional Resources

- [GitLab CI Artifacts](https://docs.gitlab.com/ee/ci/pipelines/job_artifacts.html)
- [GitLab CI Cache](https://docs.gitlab.com/ee/ci/caching/)
- [Artifact Reports](https://docs.gitlab.com/ee/ci/yaml/artifacts_reports.html)
- [Cache Best Practices](https://docs.gitlab.com/ee/ci/caching/#cache-best-practices)

## Next Steps

After completing this tutorial:
1. Optimize artifact sizes
2. Implement efficient caching strategies
3. Set up artifact cleanup policies
4. Move on to Tutorial 08: Auto DevOps

## Summary

You've learned:
- Understanding artifacts vs cache
- Implementing artifact management
- Configuring efficient caching
- Using cache fallback strategies
- Managing artifact expiration
- Generating and using reports
- Performance optimization techniques
- Best practices for artifacts and caching

This knowledge enables you to optimize pipeline performance and manage build outputs effectively.
